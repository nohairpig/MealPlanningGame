<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>營養配餐小遊戲</title>
  <link rel="stylesheet" href="food.css">
  
</head>
<body>
  <div class="stage" id="stage">
    <div class="page" id="game">

      <!-- TRAY + TRASH -->
      <section class="tray-area">
        <div class="tray-wrap">
          <div class="tray" aria-label="餐盤（同格可多樣）">
            <div class="tray-grid">
              <div class="compartment" data-slot="0"><div class="slot-body" id="slotBody0"></div></div>
              <div class="compartment circle" data-slot="1"><div class="slot-body" id="slotBody1"></div></div>
              <div class="compartment" data-slot="2"><div class="slot-body" id="slotBody2"></div></div>
              <div class="compartment large" data-slot="3"><div class="slot-body" id="slotBody3"></div></div>
              <div class="compartment" data-slot="4"><div class="slot-body" id="slotBody4"></div></div>
            </div>
          </div>
          <div class="trashring">
            <div class="ring">
              <img src="pic/ring.png" alt="出餐鈴" draggable="false"> 
              <div class="ring-hint">點擊出餐</div>
            </div>
            <div class="trash" id="trash" aria-label="垃圾桶（拖曳到此刪除）">
              <img id="trashImg" src="pic/bin_close.png" alt="垃圾桶" draggable="false">
              <div class="trash-hint">拖到這裡刪除</div>
            </div>
          </div>
        </div>
      </section>

      <!-- PANEL ✅ 一定要在 #game 裡 -->
      <section class="panel">
        <div class="tabs" role="tablist" aria-label="食物類別">
          <button class="tab veg" role="tab" aria-selected="true" data-tab="veg">蔬菜類</button>
          <button class="tab fruit" role="tab" aria-selected="false" data-tab="fruit">水果類</button>
          <button class="tab grain" role="tab" aria-selected="false" data-tab="grain">全榖雜糧類</button>
          <button class="tab protein" role="tab" aria-selected="false" data-tab="protein">蛋豆魚肉類</button>
          <button class="tab dairy" role="tab" aria-selected="false" data-tab="dairy">乳品類</button>
          <button class="tab fat" role="tab" aria-selected="false" data-tab="fat">油脂與堅果類</button>
        </div>

        <div class="foods" id="foods" aria-label="食物列表"></div>

        <div class="toolbar">
          <div class="note">
            操作：
            將食物直接拖拉至餐盤中即可。<br/>
          </div>
          <!-- 1) 在你原本的 toolbar 這段裡面（clearAll 旁邊）加一顆送出按鈕 + 顯示分數用的區塊 -->
          
          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <div class="status" id="status">已選 0 份（共 0 種）</div>

            <button class="btn secondary" id="clearAll" type="button">清空整個餐盤</button>

            <!-- ✅ 新增：結果顯示 -->
            <div class="status" id="scoreBox" style="display:none;">
              分數：<b id="scoreValue">-</b> / 5
              <span id="scoreHint" style="margin-left:8px;"></span>
            </div>
          </div>
        </div>
      </section>

      <!-- ✅ 評分遮罩 Modal -->
      <div class="score-modal" id="scoreModal" aria-hidden="true">
        <div class="score-card" role="dialog" aria-modal="true" aria-label="餐盤評分">
          <div class="score-title">你的餐盤評分</div>

          <div class="stars" id="starsRow" aria-label="星星評分"></div>

          <div class="score-text">
            分數：<b id="modalScoreValue">-</b> / 5
          </div>
          <div class="score-hint" id="modalScoreHint"></div>

          <button class="btn" id="playAgainBtn" type="button">再玩一次</button>
        </div>
      </div>


    </div>
  </div>

  <script>
  // ====== 6類食物（示範資料，可自行增刪）======
  const FOOD_DATA = {
    veg: [
      { id: "broccoli", name: "花椰菜", sub: "高纖", img: "pic/broccoli.png"},
      { id: "spinach",  name: "菠菜",   sub: "鐵質", img: "pic/spinach.png"},
      { id: "mushroom", name: "菇類",   sub: "低熱量", img: "pic/mushroom.png"},
      { id: "tomato",   name: "番茄",   sub: "茄紅素", img: "pic/tomato.png"},
      { id: "cabbage",  name: "高麗菜", sub: "家常", img: "pic/cabbage.png"},
    ],
    fruit: [
      { id: "banana",   name: "香蕉",   sub: "方便", img: "pic/banana.png"},
      { id: "apple",    name: "蘋果",   sub: "脆甜", img: "pic/apple.png"},
      { id: "orange",   name: "橘子",   sub: "維他命C", img: "pic/orange.png"},
      { id: "kiwi",     name: "奇異果", sub: "酸甜", img: "pic/kiwi.png"},
      { id: "berries",  name: "莓果",   sub: "多酚", img: "pic/berry.png"},
    ],
    grain: [
      { id: "brownrice", name: "糙米飯", sub: "全穀", img: "pic/brownrice.png"},
      { id: "sweetpot",  name: "地瓜",   sub: "根莖", img: "pic/sweetpot.png"},
      { id: "oats",      name: "燕麥",   sub: "飽足", img: "pic/oats.png"},
      { id: "corn",      name: "玉米",   sub: "香甜", img: "pic/corn.png"},
      { id: "noodle",    name: "全麥麵", sub: "替代", img: "pic/noodle.png"},
    ],
    protein: [
      { id: "egg",     name: "水煮蛋", sub: "便利", img: "pic/egg.png"},
      { id: "tofu",    name: "豆腐",   sub: "植物蛋白", img: "pic/tofu.png"},
      { id: "chicken", name: "雞胸肉", sub: "高蛋白", img: "pic/chicken.png"},
      { id: "fish",    name: "鮭魚",   sub: "好油脂", img: "pic/fish.png"},
      { id: "beans",   name: "毛豆",   sub: "纖維", img: "pic/beans.png"},
    ],
    dairy: [
      { id: "milk",   name: "牛奶",   sub: "鈣", img: "pic/milk.png"},
      { id: "yogurt", name: "優格",   sub: "益生菌", img: "pic/yogurt.png"},
      { id: "cheese", name: "起司",   sub: "濃郁", img: "pic/cheese.png"},
      { id: "soyMilk",name: "無糖豆漿", sub: "替代", img: "pic/soymilk.png"},
    ],
    fat: [
      { id: "nuts",   name: "綜合堅果", sub: "香脆", img: "pic/nuts.png" },
      { id: "avocado",name: "酪梨",   sub: "好脂肪", img: "pic/avocado.png" },
      { id: "sesame", name: "芝麻",   sub: "點綴", img: "pic/sesame.png" },
    ],
  };

  const MAX_PORTION_PER_FOOD = 3;
  const SLOT_COUNT = 5;

  // slots[slotIndex] = { foodId: portionCount, ... }
  const slots = Array.from({length: SLOT_COUNT}, () => ({}));

  // total portions per foodId (跨格加總，仍最多3)
  const portions = Object.values(FOOD_DATA).flat().reduce((acc, f) => {
    acc[f.id] = 0;
    return acc;
  }, {});

  // quick lookup
  const FOOD_LOOKUP = Object.values(FOOD_DATA).flat().reduce((acc, f) => {
    acc[f.id] = f;
    return acc;
  }, {});

  // DOM
  const foodsEl = document.getElementById("foods");
  const statusEl = document.getElementById("status");
  const tabButtons = Array.from(document.querySelectorAll(".tab"));
  const slotBodies = Array.from({length:SLOT_COUNT}, (_,i)=>document.getElementById("slotBody"+i));
  const compartments = Array.from(document.querySelectorAll(".compartment"));
  const clearAllBtn = document.getElementById("clearAll");
  const trashEl = document.getElementById("trash");
  const trashImg = document.getElementById("trashImg");
  const BIN_CLOSE = "pic/bin_close.png";
  const BIN_OPEN  = "pic/bin_open.png";


  let activeTab = "veg";

  function totalPortions(){
    return Object.values(portions).reduce((a,b)=>a+b,0);
  }
  function totalKinds(){
    return Object.values(portions).filter(v=>v>0).length;
  }
  function updateStatus(){
    statusEl.textContent = `已選 ${totalPortions()} 份（共 ${totalKinds()} 種）`;
  }

  // ===== Drag helpers =====
  // ✅ 取代你原本的 onFoodDragStart
  // 改
  function onFoodDragStart(e){
    const card = e.currentTarget;
    const foodId = card.dataset.foodId;

    e.dataTransfer.setData("text/plain", foodId);
    e.dataTransfer.effectAllowed = "copy";

    const img = card.querySelector(".food-img");
    if (!img) return;

    // ✅ 建一個隱藏的 clone，確保 drag image 穩定
    const ghost = img.cloneNode(true);
    ghost.style.width = (img.clientWidth || 64) + "px";
    ghost.style.height = "auto";
    ghost.style.position = "fixed";
    ghost.style.top = "-9999px";
    ghost.style.left = "-9999px";
    ghost.style.pointerEvents = "none";
    ghost.style.opacity = "1";
    document.body.appendChild(ghost);

    const w = ghost.clientWidth || 64;
    const h = ghost.clientHeight || 64;
    e.dataTransfer.setDragImage(ghost, Math.floor(w / 2), Math.floor(h / 2));

    // 拖曳結束移除 ghost
    const cleanup = () => {
      ghost.remove();
      card.removeEventListener("dragend", cleanup);
    };
    card.addEventListener("dragend", cleanup);
  }


  function onSlotDragOver(e){
    // 必須 preventDefault 才能 drop
    e.preventDefault();
    e.dataTransfer.dropEffect = "copy";
    e.currentTarget.classList.add("dropping");
  }
  function onSlotDragLeave(e){
    e.currentTarget.classList.remove("dropping");
  }
  function onSlotDrop(e){
    e.preventDefault();
    e.currentTarget.classList.remove("dropping");

    const slotIndex = Number(e.currentTarget.dataset.slot);
    const foodId = e.dataTransfer.getData("text/plain");
    if (!foodId) return;

    const fromSlotRaw = e.dataTransfer.getData("from-slot");

    // ✅ 從餐盤內拖曳 -> move（先從原格移除 1，再加入新格 1）
    if (fromSlotRaw !== ""){
      const fromSlot = Number(fromSlotRaw);
      if (fromSlot === slotIndex) return;

      // 先檢查目標格可不可以放（避免移走後放不進去）
      if (!canAddToSlot(foodId, slotIndex)){
        return;
      }

      removeFood(foodId, fromSlot);
      addFood(foodId, slotIndex);
      return;
    }

    // ✅ 從底部食物列拖曳 -> copy/add
    addFood(foodId, slotIndex);
  }


  // 拖曳「餐盤內」食材：用 move（不是 copy）
  function onChipDragStart(e){
    const foodId = e.currentTarget.dataset.foodId;
    const slotIndex = e.currentTarget.dataset.slot;
    if (!foodId || slotIndex === undefined) return;

    e.dataTransfer.setData("text/plain", foodId);
    e.dataTransfer.setData("from-slot", String(slotIndex));
    e.dataTransfer.effectAllowed = "move";
  }

  function openTrash(){
    trashEl.classList.add("over");
    trashImg.src = BIN_OPEN;
  }
  function closeTrash(){
    trashEl.classList.remove("over");
    trashImg.src = BIN_CLOSE;
  }

  function onTrashDragOver(e){
    e.preventDefault(); // allow drop
    e.dataTransfer.dropEffect = "move";
    openTrash();
  }

  function onTrashDragLeave(){
    closeTrash();
  }

  function onTrashDrop(e){
    e.preventDefault();
    closeTrash();

    const foodId = e.dataTransfer.getData("text/plain");
    const fromSlot = e.dataTransfer.getData("from-slot");

    // 只能刪除「從餐盤內拖出來」的（有 from-slot）
    if (!foodId || fromSlot === "") return;

    removeFood(foodId, Number(fromSlot)); // 刪 1 份
  }


  function renderFoods(){
    foodsEl.innerHTML = "";

    FOOD_DATA[activeTab].forEach(item => {
      const card = document.createElement("div");
      card.className = "food-card";
      card.dataset.foodId = item.id;
      card.setAttribute("draggable", "true");

      const p = portions[item.id] ?? 0;

      card.innerHTML = `
        <img src="${item.img}" alt="${item.name}" class="food-img">
        <div class="food-name">${item.name}</div>
        <div class="badge">${p} / ${MAX_PORTION_PER_FOOD}</div>
      `;

      card.addEventListener("dragstart", onFoodDragStart);

      foodsEl.appendChild(card);
    });
  }

  function applyAutoItemSize(){
    for (let i = 0; i < SLOT_COUNT; i++){
      const body = slotBodies[i];
      if (!body) continue;

      const w = body.clientWidth;
      const h = body.clientHeight;

      // 基礎大小：一般格
      let size = Math.floor(Math.min(w, h) * 0.40);
      let minSize = 44;
      let maxSize = 82;

      // 格 4（data-slot="3"）獨立放大（更大的倍率與上限）
      if (i === 3){
        size = Math.floor(Math.min(w, h) * 0.55);
        minSize = 70;
        maxSize = 120;
      }

      size = Math.max(minSize, Math.min(size, maxSize));
      body.style.setProperty("--itemSize", size + "px");
    }
  }

  // ✅ 食物 id -> 類別（calculatePlateScore 會用到）
  const FOOD_CATEGORY = Object.entries(FOOD_DATA).reduce((acc, [cat, list]) => {
    list.forEach(item => acc[item.id] = cat);
    return acc;
  }, {});

  // ✅ DOM：出餐鈴 + 分數顯示區
  const ringBtn = document.querySelector(".ring"); // 或 document.querySelector(".ring img")
  const scoreBox = document.getElementById("scoreBox");
  const scoreValueEl = document.getElementById("scoreValue");
  const scoreHintEl = document.getElementById("scoreHint");
  // ====== 評分 Modal DOM ======
  const scoreModal = document.getElementById("scoreModal");
  const starsRow = document.getElementById("starsRow");
  const modalScoreValue = document.getElementById("modalScoreValue");
  const modalScoreHint  = document.getElementById("modalScoreHint");
  const playAgainBtn = document.getElementById("playAgainBtn");

  // 星星圖
  const STAR_ON  = "pic/star.png";
  const STAR_OFF = "pic/graystar.png";

  // ✅ 送出前的快照（用來「再玩一次」復原）
  let snapshotSlots = null;
  let snapshotPortions = null;

  function deepCopy(obj){
    return JSON.parse(JSON.stringify(obj));
  }

  function restoreSnapshot(){
    if (!snapshotSlots || !snapshotPortions) return;

    // 還原 slots（你 slots 是 const，但內容可改）
    for (let i = 0; i < SLOT_COUNT; i++){
      slots[i] = snapshotSlots[i] || {};
    }

    // 還原 portions
    Object.keys(portions).forEach(k => {
      portions[k] = snapshotPortions[k] ?? 0;
    });

    renderSlots();
    renderFoods();
  }

  function renderStars(score){ // score: 1~5
    starsRow.innerHTML = "";
    for (let i = 1; i <= 5; i++){
      const img = document.createElement("img");
      img.src = (i <= score) ? STAR_ON : STAR_OFF;
      img.alt = (i <= score) ? "星" : "灰星";
      starsRow.appendChild(img);
    }
  }

  function openModal(){
    scoreModal.classList.add("is-open");
    scoreModal.setAttribute("aria-hidden", "false");
    document.body.classList.add("modal-open");
  }

  function closeModal(){
    scoreModal.classList.remove("is-open");
    scoreModal.setAttribute("aria-hidden", "true");
    document.body.classList.remove("modal-open");
  }

  /* ===========================
  * ✅ 同步修正：showPlateScore() 裡的預設分數
  * 原本用 || 1 會把 0 分吃掉
  * =========================== */
  function showPlateScore(){
    snapshotSlots = deepCopy(slots);
    snapshotPortions = deepCopy(portions);

    const result = calculatePlateScore();
    const score = Number.isFinite(Number(result.score)) ? Number(result.score) : 0;

    modalScoreValue.textContent = String(score);
    modalScoreHint.textContent = result.hint || "";
    renderStars(score); // score 可為 0：會顯示 0 顆星（全灰）

    openModal();
    if (scoreBox) scoreBox.style.display = "none";
  }

  if (ringBtn){
    ringBtn.addEventListener("click", showPlateScore);
  }

 
  // ✅ 鍵盤可操作（可選，但建議）
  ringBtn.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      showPlateScore();
    }
  });



  function renderSlots(){
    for (let i=0;i<SLOT_COUNT;i++){
      const slotObj = slots[i];
      const entries = Object.entries(slotObj).filter(([,cnt]) => cnt > 0);

      const chips = document.createElement("div");
      chips.className = "chips";

      entries.forEach(([foodId, cnt]) => {
        const food = FOOD_LOOKUP[foodId];
        const chip = document.createElement("div");
        chip.className = "food-item";
        chip.dataset.foodId = foodId;
        chip.dataset.slot = String(i);
        chip.setAttribute("draggable", "true");
        chip.addEventListener("dragstart", onChipDragStart);

        chip.innerHTML = `
          <div class="food-wrap" title="${food.name}">
            <img src="${food.img}" alt="${food.name}" class="food-icon" draggable="false">
            <div class="food-qty">× ${cnt}</div>
          </div>
        `;
        
        chips.appendChild(chip);
      });

      slotBodies[i].innerHTML = "";
      slotBodies[i].appendChild(chips);
      applyAutoItemSize();

    }

    // refresh food badges
    Array.from(document.querySelectorAll(".food-card")).forEach(card => {
      const id = card.dataset.foodId;
      const badge = card.querySelector(".badge");
      if (badge) badge.textContent = `${portions[id] ?? 0} / ${MAX_PORTION_PER_FOOD}`;
    });

    updateStatus();
  }

  function canAddToSlot(foodId, slotIndex){
    if ((portions[foodId] ?? 0) >= MAX_PORTION_PER_FOOD){
      alert("此食物已達 3 份上限（全盤加總）。");
      return false;
    }

    const slotObj = slots[slotIndex];
    const distinctKindsInSlot = Object.keys(slotObj).filter(k => (slotObj[k] ?? 0) > 0).length;
    const alreadyInSlot = (slotObj[foodId] ?? 0) > 0;

    const maxKinds = (slotIndex === 3) ? 3 : 2;

    if (!alreadyInSlot && distinctKindsInSlot >= maxKinds){
      alert(`此格最多只能放 ${maxKinds} 種不同食材。`);
      return false;
    }
    return true;
  }


  function addFood(foodId, slotIndex){
    if ((portions[foodId] ?? 0) >= MAX_PORTION_PER_FOOD){
      alert("此食物已達 3 份上限（全盤加總）。");
      return;
    }

    const slotObj = slots[slotIndex];

    const distinctKindsInSlot = Object.keys(slotObj).filter(k => (slotObj[k] ?? 0) > 0).length;
    const alreadyInSlot = (slotObj[foodId] ?? 0) > 0;

    // ✅ 格子種類上限：格4(索引3) = 3，其餘 = 2
    const maxKinds = (slotIndex === 3) ? 3 : 2;

    if (!alreadyInSlot && distinctKindsInSlot >= maxKinds){
      alert(`此格最多只能放 ${maxKinds} 種不同食材。`);
      return;
    }

    slotObj[foodId] = (slotObj[foodId] ?? 0) + 1;
    portions[foodId] = (portions[foodId] ?? 0) + 1;

    renderSlots();
  }


  function removeFood(foodId, slotIndex){
    const slotObj = slots[slotIndex];
    if (!slotObj[foodId]) return;

    slotObj[foodId] -= 1;
    if (slotObj[foodId] <= 0) delete slotObj[foodId];

    portions[foodId] = Math.max(0, (portions[foodId] ?? 0) - 1);

    renderSlots();
  }

  function clearAll(){
    for (let i=0;i<SLOT_COUNT;i++) slots[i] = {};
    Object.keys(portions).forEach(k => portions[k] = 0);
    renderSlots();
  }

  // tabs
  tabButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      activeTab = btn.dataset.tab;
      tabButtons.forEach(b => b.setAttribute("aria-selected", String(b === btn)));
      renderFoods();
      renderSlots();
    });
  });

  // slots: enable drop
  compartments.forEach(comp => {
    comp.addEventListener("dragover", onSlotDragOver);
    comp.addEventListener("dragleave", onSlotDragLeave);
    comp.addEventListener("drop", onSlotDrop);
  });
  trashEl.addEventListener("dragover", onTrashDragOver);
  trashEl.addEventListener("dragleave", onTrashDragLeave);
  trashEl.addEventListener("drop", onTrashDrop);


  clearAllBtn.addEventListener("click", clearAll);

  // init
  renderFoods();
  renderSlots();

  window.addEventListener("resize", () => {
    applyAutoItemSize();
  });

  // ✅ 自動縮放：讓整個遊戲介面「完整塞進螢幕」
  const gameEl  = document.getElementById("game");

  function fitGameToScreen(){
    // 先暫時清掉 transform 才能量到真實尺寸
    gameEl.style.transform = "none";

    // iOS Safari 用 visualViewport 才準（網址列伸縮會動）
    const vw = window.visualViewport ? window.visualViewport.width  : window.innerWidth;
    const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;

    // 量「內容真實大小」
    const contentW = gameEl.scrollWidth;
    const contentH = gameEl.scrollHeight;


    // 計算縮放（留一點邊界避免貼邊）
    const padding = 12;
    let s = Math.min((vw - padding*2) / contentW, (vh - padding*2) / contentH);

    // 上限不放大（桌機維持原尺寸），下限避免小到看不到
    s = Math.max(0.55, Math.min(s, 1));

    gameEl.style.transform = `scale(${s})`;
  }

  // ✅ iOS Safari：視窗高度會因網址列縮放改變，用 visualViewport 監聽最穩
  fitGameToScreen();
  window.addEventListener("resize", fitGameToScreen);
  if (window.visualViewport){
    window.visualViewport.addEventListener("resize", fitGameToScreen);
    window.visualViewport.addEventListener("scroll", fitGameToScreen);
  }


  // ✅ 比例版評分（可多份）：類別齊全 + 份量比例平衡（菜過多/肉過少都會扣分）
  function calculatePlateScore(){
    // 1) 各類別份數（全盤加總）
    const catPortions = { veg:0, fruit:0, grain:0, protein:0, dairy:0, fat:0 };

    for (const [foodId, cnt] of Object.entries(portions)){
      const n = Number(cnt) || 0;
      if (n <= 0) continue;
      const cat = FOOD_CATEGORY[foodId];
      if (cat && catPortions[cat] !== undefined){
        catPortions[cat] += n;
      }
    }

    const total = Object.values(catPortions).reduce((a,b)=>a+b,0);

    const catName = {
      veg:"蔬菜類", fruit:"水果類", grain:"全穀雜糧類",
      protein:"豆魚蛋肉類", dairy:"乳品類", fat:"油脂與堅果類"
    };

    // 0 分：空盤
    if (total === 0){
      return { score: 0, hint: "餐盤是空的", catPortions, total };
    }

    // 2) 類別齊全度
    const allCats = ["veg","fruit","grain","protein","dairy","fat"];
    const presentCats = allCats.filter(c => catPortions[c] > 0);
    const missingCats = allCats.filter(c => catPortions[c] <= 0);

    const coreCats = ["grain","veg","protein"];
    const coreMissing = coreCats.filter(c => catPortions[c] <= 0);
    const corePresent = coreMissing.length === 0;

    // 3) 份量「理想區間」判定（依你前面規格）
    const inRange = {
      grain:   (catPortions.grain === 1),
      veg:     (catPortions.veg >= 1 && catPortions.veg <= 2),
      protein: (catPortions.protein === 1),
      fruit:   (catPortions.fruit <= 1),
      dairy:   (catPortions.dairy <= 1),
      fat:     (catPortions.fat <= 1),
    };

    // 4) 偏多/失衡判定（整數扣分用）
    // 核心：grain=3、protein=3 視為偏多；fruit/dairy/fat >=2 視為偏多
    const majorIssues = [];
    if (catPortions.grain === 3)   majorIssues.push("全穀雜糧類偏多");
    if (catPortions.protein === 3) majorIssues.push("豆魚蛋肉類偏多");
    if (catPortions.fruit >= 2)    majorIssues.push("水果類偏多");
    if (catPortions.dairy >= 2)    majorIssues.push("乳品類偏多");
    if (catPortions.fat >= 2)      majorIssues.push("油脂與堅果類偏多");

    // 5) 先用「出現類別數 + 核心是否齊全」決定基礎分數
    let score = 0;

    if (presentCats.length <= 1){
      score = 0; // 只有 1 類
    } else if (presentCats.length === 2){
      score = 1;
    } else if (presentCats.length === 3){
      score = corePresent ? 2 : 1;
    } else if (presentCats.length === 4){
      score = corePresent ? 3 : 2;
    } else if (presentCats.length === 5){
      score = corePresent ? 4 : 3;
    } else { // 6 類都有
      score = 4; // 先給 4，符合「比例/份量」再升到 5
    }

    // 6) 對照你的 5 分條件：六類都有 + 核心理想 + 配角不超過 1 + 沒有「偏多」
    const perfect =
      (presentCats.length === 6) &&
      inRange.grain &&
      inRange.veg &&
      inRange.protein &&
      inRange.fruit &&
      inRange.dairy &&
      inRange.fat &&
      (majorIssues.length === 0);

    if (perfect) score = 5;

    // 7) 「缺核心」上限：少任一核心類，最多 2 分
    if (!corePresent){
      score = Math.min(score, 2);
    }

    // 8) 失衡扣分：出現 2 個以上 majorIssues → 至少降到 2；出現 1 個 → 至少降到 3（但不影響已被上限壓到的情況）
    if (majorIssues.length >= 2){
      score = Math.min(score, 2);
    } else if (majorIssues.length === 1){
      score = Math.min(score, 3);
    }

    // 9) 分數限制 0~5
    score = Math.max(0, Math.min(5, score));

    // 10) hint（最多顯示 3 個）
    const reasons = [];
    if (missingCats.length)
      reasons.push(`缺少：${missingCats.map(c => catName[c]).join("、")}`);

    if (coreMissing.length)
      reasons.push(`核心缺少：${coreMissing.map(c => catName[c]).join("、")}`);

    if (majorIssues.length)
      reasons.push(...majorIssues);

    // 最後輸出
    const result = reasons.join("\n");

    let hint = "整體搭配不錯";

    if (score === 4){
      if (majorIssues.length){
        hint = "整體營養結構正確，六大類配置大致均衡，但有一類份量略多，稍微調整即可達到理想餐盤。";
      } else if (missingCats.length){
        hint = "整體搭配良好，核心營養類別齊全，若能補齊剩餘營養類別會更完整。";
      } else {
        hint = "這是一份接近滿分的餐盤，主食、蔬菜與蛋白質配置正確，再微調比例即可更理想。";
      }
    }

    if (reasons.length){
      hint = Array.from(new Set(reasons)).slice(0, 3).join("；");
      if (reasons.length > 3) hint += "…";
    }

    return { score, hint, catPortions, total, presentCats, missingCats };
  }

  

  playAgainBtn.addEventListener("click", () => {
    closeModal();
    restoreSnapshot();
  });

  scoreModal.addEventListener("click", (e) => {
    // 點到遮罩背景才關（不要點卡片也關）
    if (e.target === scoreModal) closeModal();
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && scoreModal.classList.contains("is-open")){
      closeModal();
    }
  });

  // ===============================
  // ✅ 手機快速拖曳（Pointer Events）
  // 桌機仍用原本 HTML5 drag/drop
  // ===============================
  const isTouchDevice = () =>
    ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);

  if (isTouchDevice()) {
    // 手機避免頁面捲動干擾拖曳（只限制食物區塊）
    // 建議 food.css 也加 touch-action: none;（下面有給）
    enableFastTouchDrag();
  }

  function enableFastTouchDrag() {
    let dragging = null; // { foodId, fromSlot, ghostEl, offsetX, offsetY }

    // 把「底部 food-card」改成用 pointer 觸控拖曳
    function bindFoodCardsPointer() {
      document.querySelectorAll(".food-card").forEach(card => {
        card.draggable = false; // 手機不走 HTML5 drag
        card.addEventListener("pointerdown", onFoodPointerDown, { passive: false });
      });
    }

    // 把「餐盤內 chip」也改成用 pointer 拖曳（拖去別格或丟垃圾桶）
    function bindChipsPointer() {
      document.querySelectorAll(".food-item").forEach(chip => {
        chip.draggable = false;
        chip.addEventListener("pointerdown", onChipPointerDown, { passive: false });
      });
    }

    // 初始化綁定（並在每次 render 後再綁一次）
    const _renderFoods = renderFoods;
    renderFoods = function () {
      _renderFoods();
      bindFoodCardsPointer();
    };

    const _renderSlots = renderSlots;
    renderSlots = function () {
      _renderSlots();
      bindChipsPointer();
    };

    // 第一次立刻綁定
    bindFoodCardsPointer();
    bindChipsPointer();

    function onFoodPointerDown(e) {
      // 只處理觸控/筆
      if (e.pointerType === "mouse") return;

      e.preventDefault();

      const card = e.currentTarget;
      const foodId = card.dataset.foodId;
      const img = card.querySelector(".food-img");
      if (!foodId || !img) return;

      startDrag(e, { foodId, fromSlot: "" }, img);
    }

    function onChipPointerDown(e) {
      if (e.pointerType === "mouse") return;

      e.preventDefault();

      const chip = e.currentTarget;
      const foodId = chip.dataset.foodId;
      const fromSlot = chip.dataset.slot;
      const img = chip.querySelector(".food-icon");
      if (!foodId || fromSlot === undefined || !img) return;

      startDrag(e, { foodId, fromSlot }, img);
    }

    function startDrag(e, meta, imgEl) {
      // 做一個跟著手指走的 ghost（只顯示 png）
      const rect = imgEl.getBoundingClientRect();
      const ghost = imgEl.cloneNode(true);
      ghost.style.position = "fixed";
      ghost.style.left = rect.left + "px";
      ghost.style.top = rect.top + "px";
      ghost.style.width = rect.width + "px";
      ghost.style.height = "auto";
      ghost.style.pointerEvents = "none";
      ghost.style.zIndex = "9999";
      ghost.style.transform = "translateZ(0)";
      document.body.appendChild(ghost);

      dragging = {
        foodId: meta.foodId,
        fromSlot: meta.fromSlot, // "" 代表從底部列表來；有值代表餐盤內拖
        ghostEl: ghost,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
      };

      window.addEventListener("pointermove", onPointerMove, { passive: false });
      window.addEventListener("pointerup", onPointerUp, { passive: false });
      window.addEventListener("pointercancel", onPointerUp, { passive: false });
    }

    function onPointerMove(e) {
      if (!dragging) return;
      e.preventDefault();

      const x = e.clientX - dragging.offsetX;
      const y = e.clientY - dragging.offsetY;

      dragging.ghostEl.style.left = x + "px";
      dragging.ghostEl.style.top = y + "px";
    }

    function onPointerUp(e) {
      if (!dragging) return;
      e.preventDefault();

      // 找目前手指下方的元素
      const el = document.elementFromPoint(e.clientX, e.clientY);

      // 1) 丟垃圾桶
      const overTrash = el && (el.closest("#trash"));
      if (overTrash && dragging.fromSlot !== "") {
        removeFood(dragging.foodId, Number(dragging.fromSlot));
        cleanupDrag();
        return;
      }

      // 2) 丟到某個格子
      const comp = el && el.closest(".compartment");
      if (comp) {
        const slotIndex = Number(comp.dataset.slot);

        // 從餐盤內移動
        if (dragging.fromSlot !== "") {
          const fromSlot = Number(dragging.fromSlot);
          if (fromSlot !== slotIndex) {
            if (canAddToSlot(dragging.foodId, slotIndex)) {
              removeFood(dragging.foodId, fromSlot);
              addFood(dragging.foodId, slotIndex);
            }
          }
        } else {
          // 從底部新增
          addFood(dragging.foodId, slotIndex);
        }
      }

      cleanupDrag();
    }

    function cleanupDrag() {
      dragging.ghostEl?.remove();
      dragging = null;
      window.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", onPointerUp);
      window.removeEventListener("pointercancel", onPointerUp);
    }
  }

</script>

</body>
</html>